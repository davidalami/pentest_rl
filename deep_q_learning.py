import math
import pickle
import random
import re

import numpy as np
from gensim.models.fasttext import load_facebook_model
from sklearn.neural_network import MLPRegressor


class PasswordAgent:
    """Reinforcement Learning Agent for Password Cracking."""

    ALPHABET = "abcdefghijklmnopqrstuvwxyz0123456789"
    MAX_PASSWORD_LENGTH = 6

    # A representation of a QWERTY keyboard layout
    KEYBOARD_LAYOUT = {
        '1': (0, 0), '2': (0, 1), '3': (0, 2), '4': (0, 3), '5': (0, 4),
        '6': (0, 5), '7': (0, 6), '8': (0, 7), '9': (0, 8), '0': (0, 9),
        'q': (1, 0), 'w': (1, 1), 'e': (1, 2), 'r': (1, 3), 't': (1, 4),
        'y': (1, 5), 'u': (1, 6), 'i': (1, 7), 'o': (1, 8), 'p': (1, 9),
        'a': (2, 0), 's': (2, 1), 'd': (2, 2), 'f': (2, 3), 'g': (2, 4),
        'h': (2, 5), 'j': (2, 6), 'k': (2, 7), 'l': (2, 8),
        'z': (3, 0), 'x': (3, 1), 'c': (3, 2), 'v': (3, 3), 'b': (3, 4),
        'n': (3, 5), 'm': (3, 6)
    }

    TRAINING_BATCH_SIZE = 100000
    SCALING_FACTOR = 50

    def __init__(self, epsilon=0.05, nn_path="./models/nn_base.pickle",
                 top_n=3):
        self.epsilon = epsilon
        self.top_n = top_n
        self.nn_path = nn_path
        self.nn = self._load_nn()
        self.training_batch = []
        self.seen = set()
        self.ordered_passwords = self._load_passwords_from_file("stat_russkiwlst_top_1M.txt")
        self.unordered_passwords = set(self.ordered_passwords)
        self.embedder = load_facebook_model("cc.en.300.bin")

    def _load_passwords_from_file(self, file_path):
        """Load and preprocess passwords from the stat_russkiwlst list."""

        with open(file_path, "r") as f:
            lines = [x.strip().split() for x in f.readlines() if len(x.split()) == 2]
            return [
                pwd for _, pwd in lines
                if len(pwd) == PasswordAgent.MAX_PASSWORD_LENGTH and re.match(r"[a-z0-9]{6,}", pwd)
            ]

    def _one_hot_encode(self, s):
        """One-hot encode a string using the predefined alphabet."""

        char_to_index = {char: idx for idx, char in enumerate(PasswordAgent.ALPHABET)}
        encoding = [0] * len(PasswordAgent.ALPHABET) * PasswordAgent.MAX_PASSWORD_LENGTH
        try:
            for i, char in enumerate(s):
                if char in char_to_index:
                    start_index = i * len(PasswordAgent.ALPHABET)
                    encoding[start_index + char_to_index[char]] = 1
        except Exception as e:
            print(e)
            print(s)

        return encoding

    def _embed(self, word):
        """Embed a word using FastText and concatenate with one-hot encoding."""

        return self.embedder.wv[word].tolist() + self._one_hot_encode(word)

    def _load_nn(self):
        """Load the neural network from a pickle file or create a new one if file not found."""

        try:
            with open(self.nn_path, "rb") as f:
                return pickle.load(f)
        except FileNotFoundError:
            return MLPRegressor(hidden_layer_sizes=(516, 256, 128), max_iter=1,
                     warm_start=True, random_state=1,
                     shuffle=True)

    def _save_nn(self):
        """Save the current neural network to a pickle file."""

        with open(self.nn_path, "wb") as f:
            pickle.dump(self.nn, f)

    def _choose_action(self, state):
        """Choose the next action based on the current state."""

        if random.uniform(0, 1) < self.epsilon or not state:
            return random.choice(PasswordAgent.ALPHABET)
        else:
            predictions = self.nn.predict([self._embed(state + action) for action in PasswordAgent.ALPHABET])
            top_n_actions = np.argsort(predictions)[-self.top_n:]
            return PasswordAgent.ALPHABET[random.choice(top_n_actions)]

    def _is_geometrically_close(self, char1, char2):
        """Checks if two characters are geometrically close on a QWERTY keyboard."""
        if char1 in PasswordAgent.KEYBOARD_LAYOUT and char2 in PasswordAgent.KEYBOARD_LAYOUT:
            x1, y1 = PasswordAgent.KEYBOARD_LAYOUT[char1]
            x2, y2 = PasswordAgent.KEYBOARD_LAYOUT[char2]
            return abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1
        return False

    def _geometric_reward(self, state):
        """Calculate a reward based on geometric closeness of characters in the state."""
        reward = 0
        for i in range(len(state) - 1):
            if self._is_geometrically_close(state[i], state[i + 1]):
                reward += 0.1
        return reward

    def _get_reward(self, state):
        """Compute reward for a given state based on several criteria."""

        # Calculate the reward based on the geometric closeness of the characters in the state
        geometric_bonus = self._geometric_reward(state)

        # Check if the state is in the list of passwords we have
        if state in self.unordered_passwords:

            # If the state is purely numeric, apply the highest penalty
            if state.isdigit():
                penalty_factor = 0.1
            # If the state is purely alphabetical, apply a moderate penalty
            elif state.isalpha():
                penalty_factor = 0.7
            # Otherwise, for mixed or other types of states, do not penalize
            else:
                penalty_factor = 1
            # Calculate the reward by applying the penalty factor.
            # The reward is inversely proportional to the log of the index of the password.
            # The "+1" in the denominator ensures that the result is never infinite.
            return penalty_factor*PasswordAgent.SCALING_FACTOR / (math.log(self.ordered_passwords.index(state) + 1) + 1)

        # If the state has reached the maximum password length and isn't in the password list,
        # give the geometric bonus and apply a moderate penalty
        elif len(state) == PasswordAgent.MAX_PASSWORD_LENGTH:
            return geometric_bonus - 0.5

        # For other states that aren't at the maximum length and aren't in the password list,
        # give the geometric bonus and apply a small penalty
        return geometric_bonus - 0.1

    def _learn(self, state, action, reward):
        word = state + action
        if word not in self.seen:
            if word in self.unordered_passwords:
                self.seen.add(word)
            self.training_batch.append((word, reward))

            if len(self.training_batch) > PasswordAgent.TRAINING_BATCH_SIZE:
                positive = [x for x in self.training_batch if x[1] > 0]
                negative = [x for x in self.training_batch if x[1] < 0]
                random.shuffle(negative)
                training_batch = positive + negative[:len(positive)*5]
                random.shuffle(training_batch)
                X_batch, Y_batch = zip(*[(self._embed(x[0]), x[1]) for x in training_batch])
                self.nn.partial_fit(X_batch, Y_batch)
                self.training_batch = []

    def train(self, episodes=1000000):
        for _ in range(episodes):
            state = ""
            episode_history = []

            for _ in range(PasswordAgent.MAX_PASSWORD_LENGTH):
                action = self._choose_action(state)
                episode_history.append((state, action))
                reward = self._get_reward(state + action)
                self._learn(state, action, reward)

                if state + action in self.unordered_passwords:
                    for prev_state, prev_action in reversed(episode_history[:-1]):
                        reward *= 0.8
                        self._learn(prev_state, prev_action, reward)

                state = state + action
        self._save_nn()


if __name__ == '__main__':
    agent = PasswordAgent()
    agent.train()

